# RUNSTR PROJECT OVERVIEW

## Introduction

RUNSTR is a decentralized fitness competition platform built on Nostr and Bitcoin, enabling teams to organize charitable events, track workouts, and compete for Bitcoin prizes—all without platform fees or custodial wallets. This document provides a comprehensive overview of RUNSTR's features, architecture, and business model.

---

## 1. Competition Architecture: Events, Challenges, and Teams

### Event & Challenge Wizard Architecture

RUNSTR's event and challenge creation systems share identical wizard architectures but serve different purposes. The **Event Wizard** (`EventCreationWizard.tsx`) creates team-based competitions using kind 30101 event definitions, while the **Challenge Wizard** (`SimplifiedChallengeWizard.tsx`) creates 1v1 competitions using kind 30102 challenge definitions. Both wizards offer three preset running distances (5K, 10K, Half Marathon) with locked activity types and scoring modes (fastest time only). Events support entry fees (Free, 1k, 2.1k, 5k sats) and prize pools (None, 10k, 21k, 50k sats) with payment destinations configurable to captain wallets or team charities. Challenges use a honor-system donation pledge (Free, 1k, 2.1k, 5k, 10k sats) where the winner's charity receives the donation. Both wizards validate captain pubkeys, generate unique IDs (`event_{name}_{timestamp}` or `challenge_{name}_{timestamp}`), and publish announcement cards to Nostr as kind 1 social posts for team feed visibility.

### Nostr Event Kinds & List Management

The competition system relies on four critical Nostr event kinds: **kind 30101** (event definitions), **kind 30102** (challenge definitions), **kind 30000** (participant/member lists), and **kind 1105** (join requests). Kind 30101 events store event metadata including activity type, distance, duration, start/end dates, entry fees, and captain pubkeys. Kind 30102 challenges are limited to 2 participants maximum and include challenger/challengee pubkeys, wager amounts, and 24-48 hour durations. Kind 30000 lists serve as the "single source of truth" for team membership and event participation, using replaceable events with `d-tags` like `team-members-{teamId}` or `event-participants-{eventId}`. These lists contain `['p', pubkey]` tags for each member and are modified by captains using `NostrListService.prepareAddMember()` when approving join requests. Kind 1105 join requests differentiate between team joins and event joins using `['t', 'event-join-request']` tags, and for paid events include payment proof tags (`['payment_proof', invoice]`, `['amount_paid', sats]`, `['payment_timestamp', unix]`).

### Two-Tier Join Flow Architecture

RUNSTR's join flow implements a sophisticated **local-first + official verification** pattern that delivers instant UX while maintaining decentralized truth via Nostr lists. When users join events or teams, they're immediately added to local AsyncStorage via `EventParticipationStore.addParticipation()` or `teamMembershipService.joinTeamLocally()`, giving instant feedback without network delays. Simultaneously, a kind 1105 join request is published to Nostr containing user details and payment proof (for paid events). Captains view these requests in their dashboard via `EventJoinRequestService.getEventJoinRequests()`, which queries Nostr for pending kind 1105 events. For paid events, the `PaymentVerificationBadge` component automatically verifies payments using NWC wallet lookups (`NWCWalletService.lookupInvoice()`) or displays manual "Mark as Paid" buttons for Lightning address recipients. Once approved, captains click "Add to Official List" which triggers `NostrListService.prepareAddMember()` to publish an updated kind 30000 list with the new participant, transitioning their local status from `'pending_approval'` to `'approved'` and setting `localOnly: false`. This pattern ensures users see themselves on "My Events" and "My Teams" pages instantly while other participants only see officially approved members, giving captains full control over team/event rosters while maintaining exceptional user experience.

### Team Membership

Teams use the **identical local+official pattern** as events: team roster stored in kind 30000 list with `d-tag: 'team-members-{teamId}'`, captain publishes initial list when creating team, members added via kind 1104 team join requests (different from event join: kind 1105), and captain approval adds member to kind 30000 list. The `teamMembershipService.ts` handles `joinTeamLocally()` for instant local join, `getOfficialTeamMembers()` to query kind 30000 list from Nostr, and `isOfficialMember()` to check if user is on official list. Key difference: Teams use kind 1104 for join requests while events use kind 1105, but both are managed through similar captain approval workflows.

### Leaderboard Calculation & Splits Processing

Leaderboards are calculated client-side by querying kind 1301 workout events from participants listed in kind 30000 lists, using the `SimpleLeaderboardService` for real-time scoring. The service first fetches the event's kind 30000 participant list via `NostrListService.getListMembers()`, then queries Nostr for kind 1301 workout events filtered by participant pubkeys and competition date ranges. The critical innovation is **splits-based flexible distance matching**: kind 1301 events include `['split', km, time]` tags (e.g., `['split', '5', '00:25:30']`) that allow the leaderboard to extract partial distances from longer workouts. For example, a 10K workout with 5km splits will count for a 5K event by using the 5km split time rather than penalizing the runner for going beyond the target distance. The `extractTargetDistanceTime()` method handles exact split matches, interpolation for missing splits, and zero-scoring for incomplete workouts. Scoring supports multiple modes: **fastest_time** (lowest duration wins), **completion** (binary 1/0), **total_distance** (sum across workouts), **average_pace** (best pace min/km), and **total_calories** (sum). Rankings are calculated for ALL team members including those with zero workouts (DNF), sorted by score with 5-minute caching via `CompetitionCacheService` to reduce Nostr queries by 80%.

---

## 2. Activity Tracking System

### GPS-Based Cardio Tracking with Activity-Specific Intelligence

RUNSTR's cardio tracking system (`RunningTrackerScreen.tsx` + `LocationTrackingService.ts`) implements a sophisticated GPS tracker that dynamically adjusts its behavior based on activity type—running, walking, or cycling. The `LocationTrackingService` uses activity-specific polling intervals optimized for accuracy and battery efficiency: cycling gets the most frequent updates (1-second intervals, 10-meter distance thresholds) for precise speed calculations, running uses moderate polling (2-second intervals, 5-meter thresholds) for balanced accuracy, and walking employs conservative settings (5-second intervals, 10-meter thresholds) to conserve battery during slower movement. The system displays activity-specific metrics automatically—steps for walking, speed (km/h) for cycling, and pace (min/km) for running—all calculated from the same GPS coordinate stream using Haversine distance formulas with accuracy filtering (rejecting points with >50m accuracy to prevent GPS drift). The tracker includes pause/resume functionality with cumulative pause time tracking, ensuring "moving time" calculations remain accurate even during multi-hour workouts with multiple breaks. Distance is calculated in real-time by accumulating meters between consecutive GPS points, with elevation gain automatically computed from altitude data, and all tracking sessions are stored with complete location history, enabling post-workout split analysis and pace variation charts.

### Strength Training with Set/Rep Management and Automated Rest Timers

The strength training tracker (`StrengthTrackerScreen.tsx`) provides a guided workout system supporting six exercise types (pushups, pullups, situps, squats, curls, bench press) with intelligent rep counting and automatic rest period management. Users configure their workout upfront by selecting exercise type, target sets (1-10), target reps per set (1-100), and rest duration between sets (30/60/90/120 seconds), then the system guides them through each set with a three-phase workflow: **active phase** (user completes set → taps "Set Complete"), **rep confirmation modal** (pre-filled with target reps and last set's weight, user adjusts actual completed reps), and **rest phase** (automatic countdown timer with large circular display and "Skip Rest" option). The tracker stores granular per-set data including individual rep counts and weights (`repsBreakdown: [12, 10, 8]`, `weightsPerSet: [135, 135, 125]`), enabling detailed volume analysis for progressive overload tracking. Calorie estimation uses a sophisticated volume-based algorithm combining total weight moved (reps × weight × 0.0025 cal/lb) with time-based rest metabolism (3 cal/min), and for bodyweight exercises, the system automatically uses the user's body weight from their profile as the resistance value. The workout summary displays total reps, average weight, total volume, and estimated calories, then saves to local storage as a unified `Workout` object with type `'strength_training'` for seamless integration with multi-source workout history.

### Diet Tracking as Simplified Food Journal with Fasting Intelligence

RUNSTR's diet tracker (`DietTrackerScreen.tsx`) transforms meal logging into a friction-free experience by eliminating complex calorie counting in favor of simple meal type and size selection. Users choose from four meal types (breakfast/lunch/dinner/snack) and four sizes (small/medium/large/XL), which map to a research-backed calorie lookup table (`CalorieEstimationService.ts`) providing instant estimates without nutritional database queries—for example, a medium dinner estimates 700 calories, a large breakfast 750 calories, and a small snack 150 calories. The system's fasting tracking feature maintains a persistent "last meal timestamp" in AsyncStorage, displaying real-time "time since last meal" with second-by-second updates and milestone badges for fasting achievements (12h Circadian, 16h Intermittent, 18h Extended, 20h Warrior, 24h OMAD, 36h Monk, 48h/72h Extended Fasts). Each meal entry saves to the unified workout history with type `'diet'` including estimated calories, meal time, meal size, and optional notes, enabling the advanced analytics engine to calculate daily caloric intake totals and weekly calorie balance trends. This approach prioritizes user adherence over precision—the barrier to logging a meal is two taps (meal type + size), making it realistic for users to maintain consistent tracking habits rather than abandoning the journal due to entry complexity.

### Multi-Source Workout Aggregation with Cross-Platform Publishing

The "My Workouts" system (`PrivateWorkoutsTab.tsx`) implements a unified workout history aggregating four distinct data sources into a single chronological feed with zero loading latency. The **"On Device"** source displays all locally tracked workouts (GPS runs/walks/cycles, strength sessions, meditation sessions, diet entries) stored in AsyncStorage via `LocalWorkoutStorageService` with instant retrieval. The **"On Nostr"** source shows the user's published kind 1301 competition events fetched from Nostr relays, which can be imported back to local storage for offline access. The **"Apple Health"** integration surfaces HealthKit workouts with support for all Apple Watch activity types (outdoor runs, cycling, swimming, yoga, HIIT, dance, etc.), making the app a comprehensive workout hub even for users who prefer native fitness apps. The **"Garmin"** source is architecturally planned but not yet implemented, with placeholder infrastructure for Garmin Connect API integration. The cross-posting system enables users to publish local workouts to Nostr via two paths: **"Post to Nostr"** publishes as kind 1301 events for competition leaderboard participation (structured data with distance/duration/splits), while **"Post to Social"** generates beautiful SVG achievement cards published as kind 1 social posts for feed visibility. The import system (`Nostr1301ImportService`) allows users to pull their complete Nostr workout history into local storage with progress tracking, enabling offline analytics and backup of their decentralized fitness data.

### Advanced Analytics and Standardized Fitness Assessment

The stats page (`AdvancedAnalyticsScreen.tsx`) delivers privacy-first fitness analytics by performing all calculations locally on-device without cloud processing, analyzing strength, cardio, diet, and meditation metrics across unified workout history. Cardio analytics (`CardioPerformanceAnalytics`) calculate VO2 max estimates using Jack Daniels' VDOT formula from recent 5K run times, fitness age based on age-adjusted VO2 max norms, and resting heart rate trends when available from HealthKit. Body composition analytics (`BodyCompositionAnalytics`) compute BMI, estimated body fat percentage using Navy formula (waist/neck measurements), and lean body mass when users provide height/weight/measurement data. Caloric balance (`CaloricAnalyticsService`) totals weekly intake from diet entries and expenditure from all workout types, displaying net surplus/deficit for weight management goals. The crown jewel is the **RUNSTR Fitness Test** (`FitnessTestService.ts`), a standardized 60-minute assessment requiring users to complete three components: maximum pushups in 2 minutes, maximum situps in 2 minutes, and fastest 5K run. Users start a test session, perform workouts using the regular trackers (strength tracker for pushups/situps with 105-135 second duration validation, GPS tracker for 5K run with minimum 5000m distance validation), then finish the test to receive automatic scoring: pushups and situps award 1 point per rep (max 100 each), while the 5K run uses a time-based curve (sub-20 minutes = 100 points, sliding scale down to 40-60 minutes). The composite score (max 300) determines grade classification (Elite/Advanced/Intermediate/Developing/Baseline), and all test results save to persistent history with personal best tracking, enabling users to measure fitness progress over months and years with an objective standardized benchmark rather than subjective self-assessment.

### Meditation Tracking

The meditation tracker (`MeditationTrackerScreen.tsx`) provides a **simple timer-based system** with meditation type selection (guided, unguided, breathwork, body scan, gratitude), pause/resume functionality, and automatic calorie estimation. The timer uses React ref-based state management to track elapsed time with second-by-second updates, supports pausing with cumulative pause time tracking (similar to GPS tracker architecture), and saves completed sessions to local storage with RMR-based calorie estimation (~1 cal/min scaled by body weight). Sessions are stored as unified `Workout` objects with type `'meditation'`, integrating seamlessly with workout history and analytics systems.

---

## 3. Bitcoin & Charity Integration

### Dual-Mode Lightning Payments: NWC Integration Meets Universal Wallet Support

RUNSTR's payment infrastructure implements a sophisticated dual-mode zapping system designed to maximize accessibility while maintaining the seamless UX benefits of Nostr Wallet Connect. Users with connected NWC wallets (Alby, Mutiny, Coinos) can send **instant 21-sat quick zaps** with a single tap anywhere in the app—team rosters, leaderboards, competition results, profile pages—enabled by the `NWCLightningButton` component that appears throughout the interface via `ZappableUserRow`. For users without NWC wallets or those preferring external payment control, the **hold-to-zap gesture** (400ms long press) opens a custom amount modal generating a standard Lightning invoice payable from any Lightning-enabled wallet: Cash App, Strike, Alby's standalone app, Phoenix, Breez, Muun, or any self-custodial Lightning implementation. This architecture eliminates platform lock-in—users aren't forced into specific wallet ecosystems to participate in RUNSTR's charitable fitness competitions. The `NWCWalletService` handles all Nostr Wallet Connect operations using the Alby SDK with robust error handling (exponential backoff retry logic, iOS backgrounding detection with automatic reconnection, 30-second payment timeouts with graceful degradation). The system maintains user sovereignty: NWC connection strings are stored locally in AsyncStorage, wallets communicate directly with users' chosen Lightning nodes, and RUNSTR never sees private keys or holds custody of funds—the platform merely facilitates the payment interface while actual value transfer happens peer-to-peer across Lightning Network channels.

### Charitable Contributions Over Gamified Rewards: The Badge and Recognition Philosophy

Unlike platforms that extract fees and issue meaningless participation tokens, RUNSTR positions Bitcoin as the **medium for charitable impact** rather than personal profit. The app currently supports two major Bitcoin-aligned charities—OpenSats (funding open-source Bitcoin/Nostr development via `opensats@vlt.ge`) and Human Rights Foundation (supporting freedom advocates worldwide via `nostr@btcpay.hrf.org`)—with infrastructure built for expanding to local charities, community causes, and user-designated 501(c)(3) organizations. Teams designate their supported charity in their kind 33404 metadata, displayed prominently via the `CharitySection` component with a direct "Zap Charity" button enabling instant contributions. While the `CharitySelectionService` currently tracks user contribution statistics (`totalSatsEarned`, `lastUpdated` timestamp) and provides the architectural foundation for badge distribution, **the recognition system UI is not yet implemented**. The vision—badges and shoutouts for charitable supporters—represents RUNSTR's differentiation from exploitative micropayment apps: instead of rewarding users with platform tokens for watching ads or clicking engagement bait, RUNSTR would recognize users for **actual charitable impact** (e.g., "10K sats donated to OpenSats," "50 charity zaps sent," "Monthly HRF supporter"). This approach aligns incentives toward positive-sum community building rather than zero-sum competition for scarce platform rewards, leveraging Bitcoin's medium-of-exchange properties to route value toward public goods rather than platform shareholders.

### Privacy-Preserving Charity Event Payments: The Captain Verification Model

The most challenging design constraint for charitable fitness events is balancing **payment verification** (proving users paid to participate) with **payment privacy** (preventing surveillance of individual contributions). RUNSTR's current implementation uses a **captain-as-intermediary model**: event entry fees flow to the team captain's Lightning wallet (via their configured Lightning address or NWC connection), captains verify payments through the `PaymentVerificationBadge` system (automatic NWC lookup via `lookupInvoice()` or manual "Mark as Paid" button), then captains forward appropriate amounts to designated charities with **provable Nostr zaps** (future implementation of kind 9735 zap receipts). This architecture preserves privacy because individual payment amounts and timing remain visible only to the captain and payer—neither RUNSTR nor other participants see transaction details. The `EventTransactionHistory` component shows captains their incoming payments filtered by event entry fee amounts (±1% tolerance for Lightning routing fee variations), enabling transparent accounting without broadcasting payment data to the entire team. The manual forwarding step—captains deciding what percentage of entry fees to donate—maintains human discretion rather than automatic deductions, though future iterations could implement **direct charity invoice generation** bypassing captains entirely. The tricky balance: official race leaderboards require payment verification to prevent free riders, yet requiring captains to manually approve each participant creates friction. The solution lies in **trust-minimized verification**: Lightning invoices include payment preimages that prove payment settlement without revealing payer identity, and kind 9735 Nostr zap receipts (not yet implemented) would provide cryptographic proof of captain→charity forwarding visible to all participants.

### The 5K Organizer Use Case: Bitcoin-Aligned Community Events

RUNSTR's target market—Bitcoin and Nostr users organizing charity 5Ks, 10Ks, and half marathons—represents an underserved niche frustrated by traditional fundraising platforms charging exploitative fees. The `CHARITY_PARTNERSHIP_PROGRAM.md` explicitly contrasts RUNSTR (0% platform fee + 0.1% Lightning routing) against Eventbrite (10-15% ticket fees), GoFundMe (3-5% donation fees), and RaceJoy (subscription + per-event charges), calculating **$1,490 in savings per $10,000 raised** through RUNSTR versus legacy platforms. The value proposition for race organizers: (1) **Universal wallet support** eliminates payment processor lock-in—participants pay with Cash App, Strike, Alby, or self-custodial wallets without creating platform accounts, (2) **Instant settlement** via Lightning Network means funds arrive in captain wallets within seconds rather than waiting 7-14 days for payment processor releases, (3) **Provable donations** through Nostr zap receipts provide transparent proof-of-contribution viewable by all participants, (4) **Real-time leaderboards** combine athletic performance tracking (via kind 1301 workout events) with contribution verification (via payment proofs). The `EventCreationWizard` enables captains to configure entry fees (Free/1k/2.1k/5k sats), prize pools (None/10k/21k/50k sats), and payment destinations (captain wallet OR charity direct), with the "official leaderboard" query filtering participants by payment verification status—users who haven't paid see a "Pay Entry Fee to Join Official Leaderboard" prompt, while verified payers appear in ranked order with their race times and charitable contribution badges.

### Bitcoin as Medium of Exchange: The Zero-Middleman Philosophy

RUNSTR's implementation reflects a principled stance against rent-seeking intermediaries extracting value from peer-to-peer transactions. The architecture enforces **zero platform fees**—no percentage taken from zaps, entry fees, prize pools, or charitable contributions—with revenue generated exclusively through optional Premium subscriptions ($4.99/month for advanced analytics, unlimited teams, priority support) rather than transaction-based extraction. The `bitcoinUtils.ts` file originally included a `calculateWagerFees()` function implementing 2% platform fees, but this code appears **deprecated and unused** throughout the actual payment flows, suggesting an architectural pivot toward zero-fee operation. The `NWCWalletService` uses Nostr Wallet Connect specifically because it's **non-custodial**—teams control their own Lightning wallets, RUNSTR never holds funds, and payment routing happens directly between user wallets and recipient addresses without platform intermediation. The Lightning Network itself embodies this philosophy: routing fees average 0.1% (often just 1-10 sats per payment) compared to credit card networks charging 2-3% plus fixed per-transaction fees. By building on Bitcoin's Lightning layer and Nostr's decentralized communication protocol, RUNSTR eliminates the structural necessity for middleman extraction—there's no payment processor charging interchange fees, no escrow service holding funds for settlement periods, no platform treasury pooling user balances. The result is **100% of entry fees flowing to designated causes**, 100% of zaps reaching intended recipients, and 100% of prize pools distributed to competition winners. This architecture isn't just technically superior—it's morally aligned with Bitcoin's original vision as peer-to-peer electronic cash, enabling direct value transfer between participants without intermediaries taking oversized cuts simply for providing database access and payment routing infrastructure that costs fractions of a penny per transaction.

---

## 4. Subscription Model

### Subscription Pricing & Value Proposition

RUNSTR's monetization strategy centers on a **$4.99/month or $49/year premium subscription** (17% annual discount) positioned as the affordable alternative to expensive fitness platforms. At 59% cheaper than Strava Premium ($12/month) and without requiring $300+ hardware like Garmin Coach, RUNSTR targets the sweet spot between "too cheap to be credible" and "expensive luxury service," offering what the pricing strategy document calls "great value, affordable, accessible" positioning. The subscription implementation specification (`SUBSCRIPTION_IMPLEMENTATION_SPEC.md`) details a RevenueCat-based infrastructure (chosen over Stripe for native mobile payment handling) with a 7-day free trial requiring payment method upfront to reduce fraud while maximizing conversion. The business model projects 15% conversion rates at scale—10,000 users yielding 1,500 subscribers generating $73,500 ARR in Year 1, scaling to 200,000 users with 30,000 subscribers producing $1.47M ARR by Year 3. The critical insight driving this pricing: RUNSTR doesn't extract fees from community features (event creation, team management, charity donations remain 100% free), instead monetizing individual users seeking advanced performance insights. This separation enables viral growth through free captain/organizer tools while building sustainable SaaS revenue from engaged athletes willing to pay for data-driven training optimization.

### RUNSTR Season: Exclusive Quarterly Competition for Subscribers

The **RUNSTR Season** represents the app's flagship premium feature—a 3-month global fitness competition combining running, walking, and cycling distances into unified leaderboards with substantial Bitcoin prize pools. Season 1 (July 11 - October 9, 2025) awarded 200,000 sats (~$130-140 USD) distributed across top performers in each category, demonstrating the competitive prestige model that drives subscription value. The Season page displays real-time leaderboards powered by `Season1Service.ts` using static JSON data for instant performance, countdown timers showing days remaining in the current season, prize pool breakdowns, and sponsor branding (e.g., "RUNSTR Season 2: Sponsored by PlebLab"). The competitive structure incentivizes consistent tracking across all three cardio modalities—a runner who also logs cycling and walking workouts has three chances to place in top 3 rather than competing in single category, increasing engagement breadth. The quarterly cadence (Q1, Q2, Q3, Q4 seasons) creates natural retention cycles—users who subscribe in January for Q1 Season are likely to maintain subscriptions through December to compete in all four seasons, reducing churn compared to monthly feature drops. The pricing strategy explicitly positions Season access as the "premium hook" driving conversions: free users see promotional cards advertising current season leaderboards and prize pools, but clicking "View Season Leaderboard" triggers the paywall modal with messaging like "Join 10,000+ athletes competing in RUNSTR Season 2" and "7-day free trial" call-to-action.

### Stats Page: Privacy-First Performance Analytics

The premium **Advanced Stats page** (`AdvancedAnalyticsScreen.tsx`) delivers comprehensive fitness analytics typically requiring expensive lab testing or proprietary hardware, all calculated locally on-device for privacy preservation. The analytics suite includes **VO2 Max estimation** using Jack Daniels' VDOT formula from recent 5K run times (predicting maximal oxygen uptake without treadmill testing), **fitness age calculation** comparing user's VO2 Max against age-adjusted population norms to estimate biological vs chronological age (e.g., a 35-year-old with excellent VO2 Max might have fitness age of 25), **BMI and body composition tracking** via Navy formula using waist/neck measurements, and **weekly caloric balance analysis** totaling intake from diet entries against expenditure from all workout types. The `CardioPerformanceAnalytics.ts`, `BodyCompositionAnalytics.ts`, `CaloricAnalyticsService.ts`, and `StreakAnalyticsService.ts` services power these calculations entirely client-side—no server uploads, no cloud processing, no data mining for ad targeting. The stats page features visual components including the **Health Snapshot Card** (unified VO2 Max/fitness age/BMI display), **Weekly Summary Accordion** (collapsible week-by-week workout breakdowns), and **RUNSTR Fitness Test** integration showing test history and personal best tracking. The paywall implementation (currently specified but not implemented) would wrap the entire screen in a `<PremiumFeatureGate>` component, showing blurred analytics previews with overlaid messaging: "Unlock Advanced Stats - See your VO2 Max, fitness age, body composition, and weekly trends with Premium."

### Future Premium Features: Personalized Workout Plans

While not yet implemented, the subscription roadmap includes **RUNSTR Workout Plans**—personalized training programs adapting to user fitness levels, goals, and available equipment. The vision outlined in business planning documents positions workout plans as the natural evolution of the analytics foundation: once RUNSTR knows your VO2 Max (from stats page), fitness test scores (pushups/situps/5K performance), and workout history consistency (from streak analytics), the system can generate customized training programs matching your capabilities and objectives. Example use cases: a user with VO2 Max of 45 targeting half marathon completion would receive 12-week progressive plan building weekly mileage safely, while a user scoring "Developing" on fitness test would receive foundational strength/cardio hybrid program addressing weak areas. The workout plan feature would integrate with existing tracking infrastructure—each day's prescribed workout (e.g., "5 mile easy run at 9:30 min/mi pace" or "4 sets of 12 pushups with 60s rest") becomes a tracked activity via GPS tracker or strength tracker, with completion status feeding back into plan adaptation algorithms. This creates a virtuous cycle: free users get unlimited tracking and competition access driving habit formation, premium subscribers receive personalized guidance maximizing those habits, and continuous tracking data improves plan recommendations over time. The monetization psychology: serious athletes already spending $200+ on training plans (TrainingPeaks, Zwift coaching, etc.) view $4.99/month as exceptional value for integrated tracking + planning in single app.

### Free Platform Philosophy: Maximizing Charitable Impact Through Zero-Fee Community Features

RUNSTR's business model embodies a principled stance: **monetize individual premium services, never extract rent from community features**. The free tier includes everything needed to organize and participate in charitable fitness events—unlimited team creation, unlimited competition hosting, unlimited event participation, full GPS workout tracking across all activity types, beautiful SVG social cards for workout sharing, real-time leaderboards with automatic scoring, Lightning payment integration for entry fees with 0% platform commission, and captain dashboards for member management. This 100% free community infrastructure positions RUNSTR as the anti-Eventbrite: where legacy platforms charge 10-15% of ticket sales plus payment processing fees (costing organizers $1,490 per $10K raised), RUNSTR enables race organizers to keep every sat collected minus only the 0.1% Lightning Network routing fees. The `CHARITY_PARTNERSHIP_PROGRAM.md` explicitly markets this differentiation: "RUNSTR = $0 platform fee + $10 Lightning fee = $10 total cost. Eventbrite = $1,500 platform + processing fees. Savings: $1,490 per $10K raised." The free-forever community features solve the cold start problem—captains organizing 5Ks for Bitcoin charities (OpenSats, HRF) become platform evangelists recruiting participants, those participants become engaged users tracking workouts and competing in events, and 15% of engaged users convert to premium subscriptions for advanced analytics and seasonal competitions. The result: a sustainable SaaS business (82% gross margins, 6:1 LTV:CAC ratio projected) that maximizes charitable impact rather than platform extraction, with revenue generated from value-added individual services rather than taxing community transactions.

---

## 5. Additional Features

### Text-to-Speech Workout Coaching System

RUNSTR implements a sophisticated **voice coaching system** that transforms the app into an interactive audio training companion during workouts. The `TTSAnnouncementService.ts` and `TTSPreferencesService.ts` modules provide real-time audio feedback with **automatic audio ducking**—when announcements trigger, the service lowers music and podcast volume using iOS audio session interruption modes (`InterruptionModeIOS.DuckOthers`), speaks the announcement, then restores media volume. Users receive comprehensive post-workout voice summaries: "You completed a 5.2 kilometer run in 30 minutes and 45 seconds at an average pace of 5 minutes 54 seconds per kilometer. You burned 312 calories. Great work!" The system also provides **live kilometer split callouts** during runs, announcing pace for each completed kilometer in real-time to help athletes maintain target speeds without constantly checking their screen. The `TTSPreferencesService` stores user preferences for speech rate (adjustable from 0.5x to 2.0x speed), enabling fast-paced runners to get quick updates while slower-paced walkers can use more deliberate pronunciation. The natural language formatting engine converts numeric values into conversational speech patterns—"5 minutes and 30 seconds per kilometer" instead of robotic "five colon thirty"—making announcements feel like a human coach rather than a text-to-speech robot. Users control announcement granularity: toggle summary announcements on/off, include/exclude splits in post-workout summaries, and enable/disable live split announcements for distraction-free training when desired.

### Daily Bitcoin Rewards for Workout Consistency

Beyond competition prizes and peer-to-peer zapping, RUNSTR implements an **automated daily reward system** (`DailyRewardService.ts`, `RewardSenderWallet.ts`) that silently rewards users for maintaining workout consistency. Every user who completes their **first workout of the day receives 50 sats automatically** paid directly to their Lightning address without any manual claiming or button clicking. The system uses LNURL protocol to request invoices from users' Lightning addresses (the `lud16` field in their Nostr profile), generates 50-sat payment requests, and settles them via a dedicated reward sender wallet configured with Nostr Wallet Connect (`REWARD_SENDER_NWC` environment variable). The brilliant UX decision: **silent failure philosophy**—if reward payment fails (user has no Lightning address configured, invoice expires, payment times out, wallet offline), the user never sees an error message and workout publishing always succeeds regardless. Rewards are treated as a bonus feature rather than guaranteed payment, eliminating user frustration from failed micropayments while still providing delightful "surprise sats" when everything works. The `RewardSenderWallet` maintains eligibility tracking via local storage (`@runstr:last_reward_date`), preventing multiple 50-sat claims within the same day, and cumulative reward counters track total sats earned over user lifetime. This architecture incentivizes daily workout habits without creating dopamine-manipulation gamification—users work out for health/competition, then occasionally notice unexpected Bitcoin deposited into their wallet as a bonus rather than chasing micropayment rewards.

### GPS Route Management and Discovery System

RUNSTR includes a complete **saved routes infrastructure** (`SavedRoutesScreen.tsx`, `RouteStorageService.ts`) enabling athletes to build personal route libraries with rich metadata and discovery capabilities. Users can save GPS routes from completed workouts by tapping "Save Route" on workout detail screens, providing custom names, descriptions, and searchable tags (e.g., "Morning Loop," "Hilly 10K," "Scenic Trail"). The `RouteStorageService` persists route polylines (complete GPS coordinate sequences), calculates and stores distance, elevation gain, estimated difficulty ratings, and tracks usage counts showing how many times each route has been repeated. The **route library screen** provides filtering by activity type (running/walking/cycling), search by name/tags, and sorting options (recently used, most used, longest distance, highest elevation). Athletes can load saved routes before starting new workouts, enabling **route replay functionality**—the app overlays their current position against the saved route polyline, showing real-time deviation and automatically comparing performance metrics to previous attempts on the same course. This route comparison feature calculates PRs (personal records) specific to individual routes rather than just overall bests, answering questions like "Did I beat my time on the Central Park Loop?" The routes can be shared to Nostr via kind 1301 workout events (route polyline encoded in tags), enabling team members to discover and replicate each other's favorite courses for virtual group runs or competition standardization where everyone runs the exact same GPS-verified route.

### Comprehensive Onboarding and User Discovery Architecture

RUNSTR's **user onboarding system** (`OnboardingScreen.tsx`, `OnboardingWizard.tsx`, `PasswordNotice.tsx`) guides new users through a multi-step setup flow balancing education, security, and instant access. The onboarding wizard presents educational slides introducing core concepts (teams, competitions, Bitcoin rewards) via swipeable cards with visual examples and concise explanations, avoiding overwhelming new users with technical Nostr/Bitcoin jargon. The security-critical **password backup step** displays the user's auto-generated nsec (Nostr private key) in a dedicated `PasswordNotice` screen with copy-to-clipboard functionality, loud red warning text emphasizing "SAVE THIS KEY—NO PASSWORD RECOVERY EXISTS," and checkboxes forcing explicit acknowledgment before proceeding. The `PermissionRequestStep` component gracefully requests location (GPS tracking), motion (step counting), and camera (QR scanning) permissions with plain-language explanations of why each permission enhances functionality rather than demanding blanket access. The `OnboardingCacheService` prefetches teams, user profiles, and competition data during onboarding animations, loading screens, or permission approval delays—transforming wasted user time into background data hydration so that when users reach the main app, everything displays instantly without loading spinners. Complementing onboarding, the **global user discovery system** (`UserDiscoveryService.ts`) enables finding any Nostr user for 1v1 challenges through multi-method search: display name fuzzy matching, NIP-05 identifier lookup (username@domain.com), npub/hex pubkey exact matching, and activity-based recommendations. The service classifies discovered users as "active" (workouts in last 30 days), "inactive" (older workouts exist), or "new" (no workout history), helping users find worthy competition opponents, and maintains a "recent challengers" list with challenge counts and last-challenged timestamps for quick rematches.

### Advanced Wallet Infrastructure and Financial Management

Beyond simple zapping, RUNSTR implements a **comprehensive Bitcoin wallet interface** with 14 dedicated wallet components handling receiving, sending, transaction history, and automated treasury management. The **auto-withdraw system** (`AutoWithdrawSection.tsx`) enables users to configure automatic Lightning withdrawals—when wallet balance exceeds a threshold (e.g., 10,000 sats), the app automatically requests an invoice from their configured Lightning address and sweeps funds without manual intervention, perfect for captains managing event entry fees who want automatic forwarding to charity wallets. The **transaction history component** (`EventTransactionHistory.tsx`) provides filterable, searchable transaction lists showing incoming/outgoing payments with date ranges, amount filters, and CSV export functionality for accounting purposes. The **earnings summary dashboard** aggregates Bitcoin received from multiple sources: competition winnings, challenge victories, peer zaps, and daily workout rewards, displaying lifetime totals, monthly breakdowns, and source attribution. Users can generate **QR code invoices** for receiving payments with customizable amounts and memo fields, useful for captains collecting entry fees or teams receiving charitable contributions. The **send interface** supports paying Lightning invoices (via QR scan or text paste) and sending to Lightning addresses (username@domain.com format) with amount input, currency conversion (sats ↔ fiat), and optional memo fields. The **NWC configuration screen** guides users through connecting Nostr Wallet Connect wallets via QR scanning (from Alby, Mutiny, Coinos) with connection validation, relay connectivity checks, and permission scoping (pay invoices, create invoices, check balance). This wallet infrastructure positions RUNSTR as a daily-use Lightning wallet interface embedded within a fitness app, rather than requiring users to constantly switch between fitness tracking and separate payment apps.

---

## Conclusion

RUNSTR represents a paradigm shift in fitness app design—combining decentralized social networking (Nostr), peer-to-peer payments (Bitcoin Lightning), and privacy-first analytics into a platform that empowers communities to organize charitable events without platform extraction. The architecture prioritizes user sovereignty (non-custodial wallets, local data storage), charitable impact (zero-fee events, direct charity contributions), and athletic performance (GPS tracking, voice coaching, standardized fitness testing) in a cohesive system where technology serves users rather than extracting value from them.

**Key Differentiators:**
- **Decentralized**: Built on Nostr protocol, no centralized database or account system
- **Non-custodial**: Users control their Bitcoin via NWC, RUNSTR never holds funds
- **Zero platform fees**: 100% of donations/entry fees reach intended recipients
- **Privacy-first**: All analytics calculated locally, no data mining or cloud uploads
- **Bitcoin-native**: Lightning payments integrated throughout for instant global transactions
- **Open ecosystem**: Workouts published as Nostr events, interoperable with any Nostr client

For technical implementation details, architecture patterns, and development guidelines, see [CLAUDE.md](./CLAUDE.md).
